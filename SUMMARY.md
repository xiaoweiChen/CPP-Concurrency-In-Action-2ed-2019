# 目  录

* [第一版的赞许](content/Praise_for_the_first_edition.md)
* [前言](content/preface-chinese.md)
* [感谢](content/acknowledgments-chinese.md)
* [关于本书](content/about_this_book/about_this_book-chinese.md)
* [关于作者]()
* [关于封面](content/about_cover_illustration/about_cover_illustration-chinese.md)
* [第1章 你好，C++的并发世界](content/chapter1/1.0-chinese.md)
  * [1.1 何谓并发](content/chapter1/1.1-chinese.md)
  * [1.2 为什么使用并发？](content/chapter1/1.2-chinese.md)
  * [1.3 `C++`中的并发和多线程](content/chapter1/1.3-chinese.md)
  * [1.4 开始入门](content/chapter1/1.4-chinese.md)
* [第2章 线程管理](content/chapter2/2.0-chinese.md)
  * [2.1 线程管理的基础](content/chapter2/2.1-chinese.md)
  * [2.2 向线程函数传递参数](content/chapter2/2.2-chinese.md)
  * [2.3 转移线程所有权](content/chapter2/2.3-chinese.md)
  * [2.4 运行时决定线程数量](content/chapter2/2.4-chinese.md)
  * [2.5 识别线程](content/chapter2/2.5-chinese.md)
* [第3章 线程间共享数据](content/chapter3/3.0-chinese.md)
  * [3.1 共享数据带来的问题](content/chapter3/3.1-chinese.md)
  * [3.2 使用互斥量保护共享数据](content/chapter3/3.2-chinese.md)
  * [3.3 保护共享数据的可选方式](content/chapter3/3.3-chinese.md)
* [第4章 同步并发操作](content/chapter4/4.0-chinese.md)
  * [4.1 等待一个事件或其他条件](content/chapter4/4.1-chinese.md)
  * [4.2 使用期望等待一次性事件](content/chapter4/4.2-chinese.md)
  * [4.3 限定等待时间](content/chapter4/4.3-chinese.md)
  * [4.4 使用同步操作简化代码](content/chapter4/4.4-chinese.md)
* [第5章 `C++`内存模型和原子类型操作](content/chapter5/5.0-chinese.md)
  * [5.1 内存模型基础](content/chapter5/5.1-chinese.md)
  * [5.2 `C++`中的原子操作和原子类型](content/chapter5/5.2-chinese.md)
  * [5.3 同步操作和强制排序](content/chapter5/5.3-chinese.md)
* [第6章 基于锁的并发数据结构设计](content/chapter6/6.0-chinese.md)
  * [6.1 为并发设计的意义何在？](content/chapter6/6.1-chinese.md)
  * [6.2 基于锁的并发数据结构](content/chapter6/6.2-chinese.md)
  * [6.3 基于锁设计更加复杂的数据结构](content/chapter6/6.3-chinese.md)
* [第7章 无锁并发数据结构设计](content/chapter7/7.0-chinese.md)
  * [7.1 定义和意义](content/chapter7/7.1-chinese.md)
  * [7.2 无锁数据结构的例子](content/chapter7/7.2-chinese.md)
  * [7.3 对于设计无锁数据结构的指导建议](content/chapter7/7.3-chinese.md)
* [第8章 并发代码设计](content/chapter8/8.0-chinese.md)
  * [8.1 线程间划分工作的技术](content/chapter8/8.1-chinese.md)
  * [8.2 如何让数据紧凑？](content/chapter8/8.2-chinese.md)
  * [8.3 为多线程性能设计数据结构](content/chapter8/8.3-chinese.md)
  * [8.4 设计并发代码的注意事项](content/chapter8/8.4-chinese.md)
  * [8.5 在实践中设计并发代码](content/chapter8/8.5-chinese.md)
* [第9章 高级线程管理](content/chapter9/9.0-chinese.md)
  * [9.1 线程池](content/chapter9/9.1-chinese.md)
  * [9.2 中断线程](content/chapter9/9.2-chinese.md)
* [第10章 多线程程序的测试和调试](content/chapter10/10.0-chinese.md)
  * [10.1 与并发相关的错误类型](content/chapter10/10.1-chinese.md)
  * [10.2 定位并发错误的技术](content/chapter10/10.2-chinese.md)
  * [10.3 C++标准库中的并行算法](content/chapter10/10.3-chinese.md)
* [第11章 测试和调试多线程应用]()
  * [11.1 与并发相关的Bug]()
  * [11.2 定位并发Bug的技巧]()
* [附录A `C++`11语言特性简明参考(部分)](content/appendix_A/A.0-chinese.md)
  * [A.1 右值引用](content/appendix_A/A.1-chinese.md)
  * [A.2 删除函数](content/appendix_A/A.2-chinese.md)
  * [A.3 默认函数](content/appendix_A/A.3-chinese.md)
  * [A.4 常量表达式函数](content/appendix_A/A.4-chinese.md)
  * [A.5 Lambda函数](content/appendix_A/A.5-chinese.md)
  * [A.6 变参模板](content/appendix_A/A.6-chinese.md)
  * [A.7 自动推导变量类型](content/appendix_A/A.7-chinese.md)
  * [A.8 线程本地变量](content/appendix_A/A.8-chinese.md)
  * [A.9 本章总结](content/appendix_A/A.9-chinese.md)
* [附录B 并发库简要对比](content/appendix_B/B.0-chinese.md)
* [附录C 消息传递框架与完整的ATM示例](content/appendix_C/C.0-chinese.md)
* [附录D C++线程类库参考](content/appendix_D/D.0-chinese.md)
  * [D.1 chrono头文件](content/appendix_D/D.1-chinese.md)
  * [D.2 condition_variable头文件](content/appendix_D/D.2-chinese.md)
  * [D.3 atomic头文件](content/appendix_D/D.3-chinese.md)
  * [D.4 future头文件](content/appendix_D/D.4-chinese.md)
  * [D.5 mutex头文件](content/appendix_D/D.5-chinese.md)
  * [D.6 ratio头文件](content/appendix_D/D.6-chinese.md)
  * [D.7 thread头文件](content/appendix_D/D.7-chinese.md)
* [资源](content/resources/resource.md)
